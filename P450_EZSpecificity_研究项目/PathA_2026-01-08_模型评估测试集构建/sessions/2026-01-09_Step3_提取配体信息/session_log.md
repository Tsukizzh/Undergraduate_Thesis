# Session记录 - Step 3: 提取配体信息

## 基本信息
- 时间：2026-01-09
- 步骤：Step 3
- 任务：提取配体信息（底物SMILES）

---

## 一、这一步要做什么？为什么要做？

### 1.1 目标
EZSpecificity模型需要三个输入文件：
1. `Enzymes.csv` - 酶的氨基酸序列 ✅ (Step 2已完成)
2. `Substrates.csv` - **底物的SMILES表示** ← 本步骤
3. `data.csv` - 酶-底物对的索引关系 (Step 4)

**SMILES是什么？**
SMILES (Simplified Molecular Input Line Entry System) 是一种用文本表示分子结构的方法。
例如：
- 水 H₂O → `O`
- 乙醇 → `CCO`
- 咖啡因 → `Cn1cnc2c1c(=O)n(c(=O)n2C)C`

### 1.2 为什么需要配体信息？
PDB晶体结构中，P450酶通常与某个小分子（配体）结合在一起。这个配体可能是：
- **底物**：酶真正催化的反应物（如睾酮、樟脑）
- **抑制剂**：阻止酶活性的分子（如咪唑类药物）
- **其他**：结晶时添加的缓冲液、溶剂、离子等

我们需要提取这些配体的SMILES，用于后续预测。

---

## 二、源数据分析

### 2.1 源数据文件说明

源数据文件：`source_data/01_核心数据/ML训练数据集_186个.csv`

这个文件是之前从RCSB PDB API获取的P450结构数据，每一行代表一个PDB结构。

### 2.2 源数据各列含义

| 列名 | 含义 | 示例 |
|------|------|------|
| `pdb_id` | PDB结构的4字符ID | 4L4E, 2CIB |
| `entity_id` | 结构中的实体编号（一个PDB可能有多个蛋白） | 1, 2 |
| `title` | 结构的标题/描述 | "Structure of CYP119..." |
| `resolution` | 分辨率（越小越清晰，单位Å） | 1.5, 2.0 |
| `experimental_method` | 实验方法 | X-ray, Cryo-EM |
| `organism_name` | 来源物种 | Homo sapiens |
| `ncbi_taxonomy_id` | NCBI物种分类ID | 9606 (人类) |
| `uniprot_ids` | UniProt蛋白ID（JSON数组格式） | ["P00183"] |
| `sequence` | 蛋白质氨基酸序列 | MTTET... |
| `sequence_length` | 序列长度 | 415 |
| `ligands` | **所有配体**（包括水、离子、辅因子等） | HEM; CAM; K |
| `species_category` | 物种分类 | bacteria, mammals |
| `bound_ligands` | **过滤后的配体**（排除了水、血红素等） | CAM:CAMPHOR |
| `has_ligand` | 是否有配体 | True, False |

### 2.3 ligands vs bound_ligands 的区别

**ligands列**（所有配体）：
```
HEM:PROTOPORPHYRIN IX CONTAINING FE; CAM:CAMPHOR; K:POTASSIUM ION; CYN:CYANIDE ION
```
包含：血红素(HEM)、底物(CAM)、离子(K)、氰化物(CYN)等所有小分子。

**bound_ligands列**（过滤后）：
```
CAM:CAMPHOR
```
只保留可能是底物/抑制剂的配体，排除了：
- HEM（血红素，P450的辅因子，不是底物）
- 水、离子、缓冲液等

**我们使用bound_ligands列**，因为它已经做了初步过滤。

### 2.4 为什么158个PDB会有176个配体条目？

**原因：有些PDB结构中同时结合了多个配体！**

bound_ligands列的格式是：`配体1; 配体2; 配体3`（用分号分隔）

**具体例子**：

| PDB | bound_ligands | 配体数量 |
|-----|---------------|---------|
| 3EJB | ZMP:...; HTG:heptyl glucoside | 2个 |
| 6WGW | CAH:5-EXO-HYDROXYCAMPHOR; CAM:CAMPHOR | 2个 |
| 5E58 | CM5:...; CPZ:4-(4-CHLOROPHENYL)IMIDAZOLE | 2个 |
| 1F4T | PIM:4-PHENYL-1H-IMIDAZOLE | 1个 |

**为什么会有多个配体？**
1. **底物+产物**：如6WGW同时结合了樟脑(CAM)和它的羟基化产物(CAH)
2. **底物+洗涤剂**：结晶时添加的洗涤剂也可能结合在蛋白上
3. **多个结合位点**：蛋白可能有多个配体结合位点

**数据统计**：
- 158个PDB
- 大多数PDB只有1个配体
- 少数PDB有2个或更多配体
- 总计176个配体条目
- 去重后134个唯一配体代码（因为同一个配体可能出现在多个PDB中）

### 2.5 问题：没有SMILES！

源数据只有配体的3字母代码（如CAM）和名称，但**没有SMILES**。
EZSpecificity需要SMILES作为输入，所以我们需要从其他来源获取。

---

## 三、技术方案选择

### 3.1 如何获取SMILES？两种方案

**方案A：从PDB文件提取**
- 读取PDB文件中的HETATM记录（配体原子坐标）
- 用RDKit重建分子结构
- 问题：PDB文件中的键级信息不完整，容易出错

**方案B：从CCD API查询** ✅ 选择此方案
- PDB有一个官方的"化学组分字典"(Chemical Component Dictionary)
- 每个3字母配体代码（如CAM）都有对应的标准SMILES
- API地址：`https://data.rcsb.org/rest/v1/core/chemcomp/{配体代码}`

### 3.2 为什么选择方案B？

**Codex的分析**：
> "CCD是权威的配体代码→SMILES映射。从PDB文件提取容易出错，因为HETATM记录缺少键级信息。"

**Gemini的分析**：
> "完全同意用CCD API。它是官方定义源，直接提供isomeric SMILES（带立体化学信息）。"

### 3.3 什么是isomeric SMILES？

分子可能有立体异构体（镜像分子），对酶特异性很重要。
- 普通SMILES：`CC(O)C` （不区分左右手）
- Isomeric SMILES：`C[C@H](O)C` （`@`符号表示立体构型）

P450酶对立体化学非常敏感，所以我们保留isomeric SMILES。

---

## 四、执行过程

### 4.1 第一步：调用CCD API获取SMILES

对134个唯一配体代码，逐个调用API：

```python
# 示例：获取CAM（樟脑）的SMILES
url = "https://data.rcsb.org/rest/v1/core/chemcomp/CAM"
response = requests.get(url)
# 返回：CC1(C)[C@@H]2CC[C@@]1(C)C(=O)C2
```

**结果**：134个配体全部成功获取SMILES，缓存到 `ligand_smiles_cache.json`

### 4.2 第二步：配体分类（关键！）

**问题**：PDB中的配体不一定都是"底物"！

Codex指出：
> "你的bound_ligands列表不等于'真正的底物'。很多是血红素、金属离子、洗涤剂、结晶添加剂、抑制剂或辅因子。"

**解决方案**：三层过滤

**第一层：黑名单排除**
这些配体肯定不是底物，直接排除：
```
水：HOH, WAT
血红素：HEM（P450的辅因子，不是底物）
金属离子：NA, CL, MG, CA, ZN, K, FE, BR, LI
结晶添加剂：GOL(甘油), EDO, PEG, SO4, PO4
缓冲液：IMD(咪唑), HIS(组氨酸), SER(丝氨酸)
洗涤剂：BOG, OCT
气体：NO(一氧化氮), SCN(硫氰酸根)
```

**第二层：关键词分类**
根据配体名称中的关键词判断：
- 底物关键词：camphor, testosterone, fatty acid, steroid...
- 抑制剂关键词：imidazole, azole, inhibitor, phenyl...

### 4.3 分类结果

| 分类 | 数量 | 说明 |
|------|------|------|
| substrate | 48 | 名称含底物关键词 |
| inhibitor | 24 | 名称含抑制剂关键词 |
| unknown | 88 | 无法自动判断，保留 |
| **exclude** | **16** | 黑名单，排除 |

### 4.4 被排除的16个配体（具体列表）

| PDB | 配体代码 | 配体名称 | 排除原因 |
|-----|---------|---------|---------|
| 2DKK | IMD | IMIDAZOLE | 缓冲液 |
| 2WIY | IMD | IMIDAZOLE | 缓冲液 |
| 3B6H | BOG | octyl glucoside | 洗涤剂 |
| 3DSK | OCT | N-OCTANE | 溶剂 |
| 4TPN | LI | LITHIUM ION | 离子 |
| 4YZR | HIS | HISTIDINE | 氨基酸 |
| 6C93 | OCT | N-OCTANE | 溶剂 |
| 6F8A | HIS | HISTIDINE | 氨基酸 |
| 6J87 | NO | NITRIC OXIDE | 气体 |
| 6KZS | IMD | IMIDAZOLE | 缓冲液 |
| 6RO8 | HIS | HISTIDINE | 氨基酸 |
| 7F3H | SER | SERINE | 氨基酸 |
| 7OQ6 | SCN | THIOCYANATE | 离子 |
| 7P5T | BR | BROMIDE ION | 离子 |
| 7Q9E | IMD | IMIDAZOLE | 缓冲液 |
| 7Y9O | IMD | IMIDAZOLE | 缓冲液 |

---

## 五、最终产出

### 5.1 生成的文件

**Substrates.csv**（125行）
- 只包含一列：`Substrate_SMILES`
- 排除了16个非底物后，剩余160对 → 125个唯一SMILES
- 这是EZSpecificity模型的输入文件

**step3_ligand_mapping.csv**（176行）
- 完整的PDB-配体映射，包含分类信息
- 列：enzyme_index, pdb_id, ligand_code, ligand_name, smiles, substrate_index, classification
- 用于追溯和验证

### 5.2 数据流总结

```
源数据 bound_ligands列
    │
    ├─ 提取134个唯一配体代码
    │
    ├─ CCD API获取SMILES
    │
    ├─ 配体分类（黑名单+关键词）
    │       │
    │       ├─ exclude: 16个 → 排除
    │       └─ 其他: 160个 → 保留
    │
    └─ 去重 → 125个唯一SMILES → Substrates.csv
```

---

## 六、待决策问题：一个酶有多个配体

### 6.1 问题描述

当前数据中，有些PDB结构同时结合了多个配体。这意味着：
- 158个PDB → 160个有效酶-配体对（排除16个后）
- 同一个酶（同一个Enzyme Index）可能对应多个底物（多个Substrate Index）

### 6.2 具体例子

| PDB | 配体1 | 配体2 | 说明 |
|-----|-------|-------|------|
| 6WGW | CAM (樟脑) | CAH (羟基樟脑) | 底物+产物 |
| 3EJB | ZMP | HTG (洗涤剂) | 底物+洗涤剂 |
| 5E58 | CM5 (洗涤剂) | CPZ (抑制剂) | 洗涤剂+抑制剂 |

### 6.3 这对模型意味着什么？

在后续的data.csv中，会出现：
```
Dock Index, Enzyme Index, Substrate Index, Label
0,          X,            A,               1    ← 6WGW + CAM
1,          X,            B,               1    ← 6WGW + CAH (同一个酶!)
```

### 6.4 潜在问题

1. **产物不是底物**：如CAH是CAM的羟基化产物，不应该被当作"底物"来预测
2. **洗涤剂不是底物**：如HTG、CM5是结晶时添加的，不是真正的底物
3. **数据不一致**：同一个酶对应多个配体，可能导致评估结果混乱

### 6.5 可选方案

| 方案 | 描述 | 优点 | 缺点 |
|------|------|------|------|
| A | 保留所有配体（当前） | 数据完整 | 产物/洗涤剂被当作底物 |
| B | 每个PDB只保留一个配体 | 简单清晰 | 可能丢失有用信息 |
| C | 人工审核多配体PDB | 最准确 | 工作量大 |

### 6.6 待用户决策

**需要用户确认**：如何处理一个酶有多个配体的情况？

---

## 七、与Codex/Gemini的讨论要点

1. **SMILES来源**：两者都同意用CCD API，而非从PDB文件提取
2. **配体分类**：Codex强调必须过滤非底物，否则会"污染"数据集
3. **立体化学**：Gemini强调保留isomeric SMILES，因为P450对手性敏感

---

## 八、重要发现：ESIBank vs 我们的流程对比

### 8.1 为什么ESIBank不会遇到"多配体"问题？

**Codex深度分析结果**（2026-01-09）

ESIBank和我们的数据流程有**根本性区别**：

| 方面 | ESIBank | 我们 |
|------|---------|------|
| **起点** | BRENDA的酶-底物关系（文献验证） | PDB实验结构 |
| **数据流** | **关系优先 → 结构其次** | **结构优先 → 关系推断** |
| **对接方式** | 一次对接一个底物 | 直接使用PDB中的配体 |
| **配体来源** | 已知是底物（BRENDA验证） | 可能是底物/产物/抑制剂/缓冲液 |

### 8.2 ESIBank的数据流程

```
BRENDA数据库
    │
    ├─ 获取"酶A能催化底物X"的关系（文献验证）
    │
    ├─ 酶A → UniProt → AlphaFold预测结构
    │
    ├─ 底物X → PubChem → SMILES
    │
    └─ AutoDock对接（一次一个底物）→ 酶-底物复合物
```

**关键点**：
- ESIBank的工作单元是"酶-底物对"
- 如果酶A有10个底物，就做10次**独立**对接
- 每个复合物**天然只有一个目标配体**
- 辅因子（如血红素）被视为受体的一部分，不是"配体"

### 8.3 我们的数据流程

```
PDB实验结构
    │
    ├─ 一个PDB文件 = 一个晶体学实验的记录
    │
    ├─ 可能同时包含：
    │       ├─ 底物（研究者想研究的）
    │       ├─ 产物（反应后生成的）
    │       ├─ 抑制剂（用于稳定结构）
    │       └─ 缓冲液/溶剂（实验条件）
    │
    └─ 直接使用PDB中的坐标（不需要对接）
```

**关键点**：
- PDB是晶体学实验的记录，不是"酶-底物反应"的记录
- 配体是实验条件的产物，不一定是"底物"
- 所以我们会遇到"多配体"问题

### 8.4 Codex的建议

将"多配体"视为**数据标注问题**，而非结构问题：

1. **明确标注角色**：为每个配体标注substrate/product/inhibitor/other
2. **只保留底物**：只有substrate作为正样本
3. **主配体选择规则**（如果必须选一个）：
   - 选择距离血红素铁最近的配体
   - 排除常见结晶添加剂
   - 优先选择有文献支持的底物

### 8.5 实验结构的优势与风险

**优势**：
- 实验结构的姿态更接近真实
- 捕获了诱导契合、水网络、真实配位

**风险**：
| 风险 | 说明 |
|------|------|
| 配体≠底物 | 很多配体是抑制剂、产物、类似物 |
| 工程化构建体 | PDB结构可能是突变体、截短体 |
| 数据集偏差 | 模型可能学习到"已结合姿态"的伪影 |

### 8.6 结论

我们遇到的"多配体"问题是**使用实验结构的必然结果**，不是错误。
需要通过**配体角色标注**来解决，而非简单地选择一个配体。

---

## 九、三种解决方案详解

基于Codex的深度分析，我们有三种可行的解决方案。计划**全部尝试**，先从最快的方案B开始。

### 9.1 方案A：只用共晶底物（严格筛选）

**核心思路**：只保留PDB配体确认是底物的结构，丢弃产物/抑制剂/未知配体。

**具体做法**：
1. 查阅每个PDB对应的文献或BRENDA数据库
2. 确认配体是否是该酶的真正底物
3. 只保留"配体=底物"的PDB
4. 如果一个PDB有多个配体，只保留底物那个

**预期结果**：
- 158个PDB → 可能只剩~80-100个
- 数据量减少，但标签更干净

**优点**：
- 最高结构精度（实验测定的底物结合姿态）
- 标签最干净（确认是底物）
- 评估结果最可信

**缺点**：
- 数据量大幅减少
- 需要人工查阅文献（耗时）
- 偏向"能结晶的底物"

**速度**：🥈 中等（需要人工审核）

---

### 9.2 方案B：多配体展开（当前数据直接使用）

**核心思路**：直接使用当前数据，每个配体作为单独的数据行。

**具体做法**：
1. 使用当前的160个有效酶-配体对
2. 每个配体作为单独的数据行
3. 对于多配体PDB，生成多行数据
4. 标注配体角色（substrate/inhibitor/unknown），但不过滤

**预期结果**：
- 158个PDB → 160个酶-配体对
- 125个唯一SMILES

**优点**：
- 最快！直接使用当前数据
- 数据量最大
- 不需要额外工作

**缺点**：
- 产物/抑制剂可能"污染"评估结果
- 标签不够干净
- 评估结果可能有偏差

**速度**：🥇 最快（直接继续）

**当前选择**：✅ 先执行此方案

---

### 9.3 方案C：虚拟对接（ESIBank风格）

**核心思路**：像ESIBank一样，从BRENDA找酶-底物关系，然后虚拟对接到PDB结构中。

**具体做法**：
1. 从BRENDA查询158个P450酶的已知底物
2. 准备受体：从PDB中移除配体，保留蛋白+血红素
3. 准备配体：将BRENDA底物的SMILES转为3D结构
4. 运行AutoDock-GPU对接
5. 后处理：生成符合EZSpecificity格式的复合物PDB

**预期结果**：
- 每个酶可能有多个BRENDA底物
- 数据量可能增加（一个酶对多个底物）
- 标签最干净（BRENDA文献验证）

**优点**：
- 解决"配体≠底物"的核心问题
- 标签来自文献验证
- 可扩展到更多底物

**缺点**：
- 对接误差（姿态可能不准）
- 需要复杂的准备工作（受体/配体处理）
- 耗时最长

**速度**：🥉 最慢（需要对接工作）

---

### 9.4 三方案对比总结

| 方面 | 方案A | 方案B | 方案C |
|------|-------|-------|-------|
| **核心思路** | 严格筛选 | 直接使用 | 虚拟对接 |
| **数据量** | ~80-100 | 160 | 可扩展 |
| **标签质量** | 高 | 中 | 高 |
| **结构精度** | 最高（实验） | 高（实验） | 中（对接） |
| **速度** | 中等 | 最快 | 最慢 |
| **工作量** | 人工审核 | 几乎无 | 对接流程 |

### 9.5 执行计划

1. **第一轮**：方案B（快速完成Path A评估）
2. **第二轮**：方案A（严格筛选，对比结果）
3. **第三轮**：方案C（如果前两轮结果不理想）

---

## 产生的文件
见 file_index.md
